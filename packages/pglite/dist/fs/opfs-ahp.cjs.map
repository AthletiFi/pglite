{"version":3,"sources":["../../../../node_modules/.pnpm/tsup@8.3.0_@microsoft+api-extractor@7.47.7_@types+node@20.16.11__postcss@8.4.47_tsx@4.19.1_typescript@5.6.3/node_modules/tsup/assets/cjs_shims.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/utils.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/constants.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/types.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/tar.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/lib/untar.js","../../../../node_modules/.pnpm/tinytar@0.1.0/node_modules/tinytar/index.js","../../src/fs/opfs-ahp.ts","../../src/fs/base.ts","../../src/fs/tarUtils.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","'use strict';\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\nvar undefined = (function(undefined) {\n  return undefined;\n})();\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nfunction isString(value) {\n  return (typeof value == 'string') ||\n    (Object.prototype.toString.call(value) == '[object String]');\n}\n\nfunction isDateTime(value) {\n  return (Object.prototype.toString.call(value) == '[object Date]');\n}\n\nfunction isObject(value) {\n  return (value !== null) && (typeof value == 'object');\n}\n\nfunction isFunction(value) {\n  return typeof value == 'function';\n}\n\nfunction isLength(value) {\n  return (typeof value == 'number') &&\n    (value > -1) && (value % 1 == 0) &&\n    (value <= MAX_SAFE_INTEGER);\n}\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) == '[object Array]';\n}\n\nfunction isArrayLike(value) {\n  return isObject(value) && !isFunction(value) && isLength(value.length);\n}\n\nfunction isArrayBuffer(value) {\n  return Object.prototype.toString.call(value) == '[object ArrayBuffer]';\n}\n\nfunction map(array, iteratee) {\n  return Array.prototype.map.call(array, iteratee);\n}\n\nfunction find(array, iteratee) {\n  var result = undefined;\n\n  if (isFunction(iteratee)) {\n    Array.prototype.every.call(array, function(item, index, array) {\n      var found = iteratee(item, index, array);\n      if (found) {\n        result = item;\n      }\n      return !found;  // continue if not found\n    });\n  }\n\n  return result;\n}\n\nfunction extend(target /* ...sources */) {\n  return Object.assign.apply(null, arguments);\n}\n\nfunction toUint8Array(value) {\n  var i;\n  var length;\n  var result;\n\n  if (isString(value)) {\n    length = value.length;\n    result = new Uint8Array(length);\n    for (i = 0; i < length; i++) {\n      result[i] = value.charCodeAt(i) & 0xFF;\n    }\n    return result;\n  }\n\n  if (isArrayBuffer(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isArrayBuffer(value.buffer)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  if (isArrayLike(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isFunction(value.toString)) {\n    return toUint8Array(value.toString());\n  }\n\n  return new Uint8Array();\n}\n\nmodule.exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\n\nmodule.exports.isUndefined = isUndefined;\nmodule.exports.isString = isString;\nmodule.exports.isObject = isObject;\nmodule.exports.isDateTime = isDateTime;\nmodule.exports.isFunction = isFunction;\nmodule.exports.isArray = isArray;\nmodule.exports.isArrayLike = isArrayLike;\nmodule.exports.isArrayBuffer = isArrayBuffer;\nmodule.exports.map = map;\nmodule.exports.find = find;\nmodule.exports.extend = extend;\nmodule.exports.toUint8Array = toUint8Array;\n","'use strict';\n\nvar NULL_CHAR = '\\u0000';\n\nmodule.exports = {\n  /* eslint-disable key-spacing */\n\n  NULL_CHAR: NULL_CHAR,\n\n  TMAGIC: 'ustar' + NULL_CHAR + '00',   // 'ustar', NULL, '00'\n  OLDGNU_MAGIC: 'ustar  ' + NULL_CHAR,  // 'ustar  ', NULL\n\n  // Values used in typeflag field.\n  REGTYPE:  0,  // regular file\n  LNKTYPE:  1,  // link\n  SYMTYPE:  2,  // reserved\n  CHRTYPE:  3,  // character special\n  BLKTYPE:  4,  // block special\n  DIRTYPE:  5,  // directory\n  FIFOTYPE: 6,  // FIFO special\n  CONTTYPE: 7,  // reserved\n\n  // Bits used in the mode field, values in octal.\n  TSUID: parseInt('4000', 8),  // set UID on execution\n  TSGID: parseInt('2000', 8),  // set GID on execution\n  TSVTX: parseInt('1000', 8),  // reserved\n\n  // file permissions\n  TUREAD:  parseInt('0400', 8),  // read by owner\n  TUWRITE: parseInt('0200', 8),  // write by owner\n  TUEXEC:  parseInt('0100', 8),  // execute/search by owner\n  TGREAD:  parseInt('0040', 8),  // read by group\n  TGWRITE: parseInt('0020', 8),  // write by group\n  TGEXEC:  parseInt('0010', 8),  // execute/search by group\n  TOREAD:  parseInt('0004', 8),  // read by other\n  TOWRITE: parseInt('0002', 8),  // write by other\n  TOEXEC:  parseInt('0001', 8),   // execute/search by other\n\n  TPERMALL:  parseInt('0777', 8),   // rwxrwxrwx\n  TPERMMASK: parseInt('0777', 8)    // permissions bitmask\n\n  /* eslint-enable key-spacing */\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar constants = require('./constants');\n\nvar recordSize = 512;\nvar defaultFileMode = constants.TPERMALL;  // rwxrwxrwx\nvar defaultUid = 0;  // root\nvar defaultGid = 0;  // root\n\n/*\n struct posix_header {           // byte offset\n char name[100];               //   0\n char mode[8];                 // 100\n char uid[8];                  // 108\n char gid[8];                  // 116\n char size[12];                // 124\n char mtime[12];               // 136\n char chksum[8];               // 148\n char typeflag;                // 156\n char linkname[100];           // 157\n char magic[6];                // 257\n char version[2];              // 263\n char uname[32];               // 265\n char gname[32];               // 297\n char devmajor[8];             // 329\n char devminor[8];             // 337\n char prefix[131];             // 345\n char atime[12];               // 476\n char ctime[12];               // 488\n };\n */\n\nvar posixHeader = [\n  // <field name>, <size>, <offset>, <used>, <format>, <parse>, [ <check> ]\n  ['name', 100, 0, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['mode', 8, 100, function(file, field) {\n    var mode = file[field[0]] || defaultFileMode;\n    mode = mode & constants.TPERMMASK;\n    return formatTarNumber(mode, field[1], defaultFileMode);\n  }, function(buffer, offset, field) {\n    var result = parseTarNumber(buffer.slice(offset, offset + field[1]));\n    result &= constants.TPERMMASK;\n    return result;\n  }],\n  ['uid', 8, 108, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultUid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['gid', 8, 116, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultGid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['size', 12, 124, function(file, field) {\n    return formatTarNumber(file.data.length, field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['modifyTime', 12, 136, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['checksum', 8, 148, function(file, field) {\n    return '        ';  // placeholder\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['type', 1, 156, function(file, field) {\n    // get last octal digit; 0 - regular file\n    return '' + ((parseInt(file[field[0]], 10) || 0) % 8);\n  }, function(buffer, offset, field) {\n    return (parseInt(String.fromCharCode(buffer[offset]), 10) || 0) % 8;\n  }],\n  ['linkName', 100, 157, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['ustar', 8, 257, function(file, field) {\n    return constants.TMAGIC;  // magic + version\n  }, function(buffer, offset, field) {\n    return fixUstarMagic(\n      parseTarString(buffer.slice(offset, offset + field[1]), true)\n    );\n  }, function(file, field) {\n    return (file[field[0]] == constants.TMAGIC) ||\n      (file[field[0]] == constants.OLDGNU_MAGIC);\n  }],\n  ['owner', 32, 265, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['group', 32, 297, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['majorNumber', 8, 329, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['minorNumber', 8, 337, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['prefix', 131, 345, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['accessTime', 12, 476, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['createTime', 12, 488, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }]\n];\n\nvar effectiveHeaderSize = (function(header) {\n  var last = header[header.length - 1];\n  return last[2] + last[1];  // offset + size\n})(posixHeader);\n\nfunction fixUstarMagic(value) {\n  if (value.length == 8) {\n    var chars = value.split('');\n\n    if (chars[5] == constants.NULL_CHAR) {\n      // TMAGIC ?\n      if ((chars[6] == ' ') || (chars[6] == constants.NULL_CHAR)) {\n        chars[6] = '0';\n      }\n      if ((chars[7] == ' ') || (chars[7] == constants.NULL_CHAR)) {\n        chars[7] = '0';\n      }\n      chars = chars.join('');\n      return chars == constants.TMAGIC ? chars : value;\n    } else if (chars[7] == constants.NULL_CHAR) {\n      // OLDGNU_MAGIC ?\n      if (chars[5] == constants.NULL_CHAR) {\n        chars[5] = ' ';\n      }\n      if (chars[6] == constants.NULL_CHAR) {\n        chars[6] = ' ';\n      }\n      return chars == constants.OLDGNU_MAGIC ? chars : value;\n    }\n  }\n  return value;\n}\n\nfunction formatTarString(value, length) {\n  length -= 1;  // preserve space for trailing null-char\n  if (utils.isUndefined(value)) {\n    value = '';\n  }\n  value = ('' + value).substr(0, length);\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarNumber(value, length, defaultValue) {\n  defaultValue = parseInt(defaultValue) || 0;\n  length -= 1;  // preserve space for trailing null-char\n  value = (parseInt(value) || defaultValue)\n    .toString(8).substr(-length, length);\n  while (value.length < length) {\n    value = '0' + value;\n  }\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarDateTime(value, length) {\n  if (utils.isDateTime(value)) {\n    value = Math.floor(1 * value / 1000);\n  } else {\n    value = parseInt(value, 10);\n    if (isFinite(value)) {\n      if (value <= 0) {\n        return '';\n      }\n    } else {\n      value = Math.floor(1 * new Date() / 1000);\n    }\n  }\n  return formatTarNumber(value, length, 0);\n}\n\nfunction parseTarString(bytes, returnUnprocessed) {\n  var result = String.fromCharCode.apply(null, bytes);\n  if (returnUnprocessed) {\n    return result;\n  }\n  var index = result.indexOf(constants.NULL_CHAR);\n  return index >= 0 ? result.substr(0, index) : result;\n}\n\nfunction parseTarNumber(bytes) {\n  var result = String.fromCharCode.apply(null, bytes);\n  return parseInt(result.replace(/^0+$/g, ''), 8) || 0;\n}\n\nfunction parseTarDateTime(bytes) {\n  if ((bytes.length == 0) || (bytes[0] == 0)) {\n    return null;\n  }\n  return new Date(1000 * parseTarNumber(bytes));\n}\n\nfunction calculateChecksum(buffer, offset, skipChecksum) {\n  var from = parseInt(offset, 10) || 0;\n  var to = Math.min(from + effectiveHeaderSize, buffer.length);\n  var result = 0;\n\n  // When calculating checksum, `checksum` field should be\n  // threat as filled with space char (byte 32)\n  var skipFrom = 0;\n  var skipTo = 0;\n  if (skipChecksum) {\n    posixHeader.every(function(field) {\n      if (field[0] == 'checksum') {\n        skipFrom = from + field[2];\n        skipTo = skipFrom + field[1];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  var whitespace = ' '.charCodeAt(0);\n  for (var i = from; i < to; i++) {\n    // 262144 = 8^6 - 6 octal digits - maximum possible value for checksum;\n    // wrap to avoid numeric overflow\n    var byte = (i >= skipFrom) && (i < skipTo) ? whitespace : buffer[i];\n    result = (result + byte) % 262144;\n  }\n  return result;\n}\n\nmodule.exports.recordSize = recordSize;\nmodule.exports.defaultFileMode = defaultFileMode;\nmodule.exports.defaultUid = defaultUid;\nmodule.exports.defaultGid = defaultGid;\nmodule.exports.posixHeader = posixHeader;\nmodule.exports.effectiveHeaderSize = effectiveHeaderSize;\n\nmodule.exports.calculateChecksum = calculateChecksum;\nmodule.exports.formatTarString = formatTarString;\nmodule.exports.formatTarNumber = formatTarNumber;\nmodule.exports.formatTarDateTime = formatTarDateTime;\nmodule.exports.parseTarString = parseTarString;\nmodule.exports.parseTarNumber = parseTarNumber;\nmodule.exports.parseTarDateTime = parseTarDateTime;\n\n","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nfunction headerSize(file) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(file) {\n  // align to record boundary\n  return Math.ceil(file.data.length / types.recordSize) * types.recordSize;\n}\n\nfunction allocateBuffer(files) {\n  var totalSize = 0;\n\n  // Calculate space that will be used by each file\n  files.forEach(function(file) {\n    totalSize += headerSize(file) + dataSize(file);\n  });\n\n  // TAR must end with two empty records\n  totalSize += types.recordSize * 2;\n\n  // Array SHOULD be initialized with zeros:\n  // from TypedArray constructor docs:\n  // > When creating a TypedArray instance (i.e. instance of Int8Array\n  // > or similar), an array buffer is created internally\n  // from ArrayBuffer constructor docs:\n  // > A new ArrayBuffer object of the specified size.\n  // > Its contents are initialized to 0.\n  return new Uint8Array(totalSize);\n}\n\nfunction writeHeader(buffer, file, offset) {\n  offset = parseInt(offset) || 0;\n\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    var value = field[3](file, field);\n    var length = value.length;\n    for (var i = 0; i < length; i += 1) {\n      buffer[currentOffset + i] = value.charCodeAt(i) & 0xFF;\n    }\n    currentOffset += field[1];  // move to the next field\n  });\n\n  var field = utils.find(types.posixHeader, function(field) {\n    return field[0] == 'checksum';\n  });\n\n  if (field) {\n    // Patch checksum field\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    var value = types.formatTarNumber(checksum, field[1] - 2) +\n      constants.NULL_CHAR + ' ';\n    currentOffset = offset + field[2];\n    for (var i = 0; i < value.length; i += 1) {\n      // put bytes\n      buffer[currentOffset] = value.charCodeAt(i) & 0xFF;\n      currentOffset++;\n    }\n  }\n\n  return offset + headerSize(file);\n}\n\nfunction writeData(buffer, file, offset) {\n  offset = parseInt(offset, 10) || 0;\n  buffer.set(file.data, offset);\n  return offset + dataSize(file);\n}\n\nfunction tar(files) {\n  files = utils.map(files, function(file) {\n    return utils.extend({}, file, {\n      data: utils.toUint8Array(file.data)\n    });\n  });\n\n  var buffer = allocateBuffer(files);\n\n  var offset = 0;\n  files.forEach(function(file) {\n    offset = writeHeader(buffer, file, offset);\n    offset = writeData(buffer, file, offset);\n  });\n\n  return buffer;\n}\n\nmodule.exports.tar = tar;\n","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nvar defaultOptions = {\n  extractData: true,\n  checkHeader: true,\n  checkChecksum: true,\n  checkFileSize: true\n};\n\nvar excludeFields = {\n  size: true,\n  checksum: true,\n  ustar: true\n};\n\nvar messages = {\n  unexpectedEndOfFile: 'Unexpected end of file.',\n  fileCorrupted: 'File is corrupted.',\n  checksumCheckFailed: 'Checksum check failed.'\n};\n\nfunction headerSize(header) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(size) {\n  // align to record boundary\n  return Math.ceil(size / types.recordSize) * types.recordSize;\n}\n\nfunction isEndOfFile(buffer, offset) {\n  var from = offset;\n  var to = Math.min(buffer.length, offset + types.recordSize * 2);\n  for (var i = from; i < to; i++) {\n    if (buffer[i] != 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction readHeader(buffer, offset, options) {\n  if (buffer.length - offset < types.recordSize) {\n    if (options.checkFileSize) {\n      throw new Error(messages.unexpectedEndOfFile);\n    }\n    return null;\n  }\n\n  offset = parseInt(offset) || 0;\n\n  var result = {};\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    result[field[0]] = field[4](buffer, currentOffset, field);\n    currentOffset += field[1];\n  });\n\n  if (result.type != 0) {  // only regular files can have data\n    result.size = 0;\n  }\n\n  if (options.checkHeader) {\n    types.posixHeader.forEach(function(field) {\n      if (utils.isFunction(field[5]) && !field[5](result, field)) {\n        var error = new Error(messages.fileCorrupted);\n        error.data = {\n          offset: offset + field[2],\n          field: field[0]\n        };\n        throw error;\n      }\n    });\n  }\n\n  if (options.checkChecksum) {\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    if (checksum != result.checksum) {\n      var error = new Error(messages.checksumCheckFailed);\n      error.data = {\n        offset: offset,\n        header: result,\n        checksum: checksum\n      };\n      throw error;\n    }\n  }\n\n  return result;\n}\n\nfunction readData(buffer, offset, header, options) {\n  if (!options.extractData) {\n    return null;\n  }\n\n  if (header.size <= 0) {\n    return new Uint8Array();\n  }\n  return buffer.slice(offset, offset + header.size);\n}\n\nfunction createFile(header, data) {\n  var result = {};\n  types.posixHeader.forEach(function(field) {\n    var name = field[0];\n    if (!excludeFields[name]) {\n      result[name] = header[name];\n    }\n  });\n\n  result.isOldGNUFormat = header.ustar == constants.OLDGNU_MAGIC;\n\n  if (data) {\n    result.data = data;\n  }\n\n  return result;\n}\n\nfunction untar(buffer, options) {\n  options = utils.extend({}, defaultOptions, options);\n\n  var result = [];\n  var offset = 0;\n  var size = buffer.length;\n\n  while (size - offset >= types.recordSize) {\n    buffer = utils.toUint8Array(buffer);\n    var header = readHeader(buffer, offset, options);\n    if (!header) {\n      break;\n    }\n    offset += headerSize(header);\n\n    var data = readData(buffer, offset, header, options);\n    result.push(createFile(header, data));\n    offset += dataSize(header.size);\n\n    if (isEndOfFile(buffer, offset)) {\n      break;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports.untar = untar;\n","'use strict';\n\n// http://www.gnu.org/software/tar/manual/html_node/Standard.html\n\nvar utils = require('./lib/utils');\nvar constants = require('./lib/constants');\nvar tar = require('./lib/tar');\nvar untar = require('./lib/untar');\n\nutils.extend(module.exports, tar, untar, constants);\n","import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n","import type { PostgresMod } from '../postgresMod.js'\nimport type { PGlite } from '../pglite.js'\nimport { dumpTar, type DumpTarCompressionOptions } from './tarUtils.js'\n\nexport const WASM_PREFIX = '/tmp/pglite'\nexport const PGDATA = WASM_PREFIX + '/' + 'base'\n\nexport type FsType = 'nodefs' | 'idbfs' | 'memoryfs' | 'opfs-ahp'\n\n/**\n * Filesystem interface.\n * All virtual filesystems that are compatible with PGlite must implement\n * this interface.\n */\nexport interface Filesystem {\n  /**\n   * Initiate the filesystem and return the options to pass to the emscripten module.\n   */\n  init(\n    pg: PGlite,\n    emscriptenOptions: Partial<PostgresMod>,\n  ): Promise<{ emscriptenOpts: Partial<PostgresMod> }>\n\n  /**\n   * Sync the filesystem to any underlying storage.\n   */\n  syncToFs(relaxedDurability?: boolean): Promise<void>\n\n  /**\n   * Sync the filesystem from any underlying storage.\n   */\n  initialSyncFs(): Promise<void>\n\n  /**\n   * Dump the PGDATA dir from the filesystem to a gziped tarball.\n   */\n  dumpTar(\n    dbname: string,\n    compression?: DumpTarCompressionOptions,\n  ): Promise<File | Blob>\n\n  /**\n   * Close the filesystem.\n   */\n  closeFs(): Promise<void>\n}\n\n/**\n * Base class for all emscripten built-in filesystems.\n */\nexport class EmscriptenBuiltinFilesystem implements Filesystem {\n  protected dataDir?: string\n  protected pg?: PGlite\n\n  constructor(dataDir?: string) {\n    this.dataDir = dataDir\n  }\n\n  async init(pg: PGlite, emscriptenOptions: Partial<PostgresMod>) {\n    this.pg = pg\n    return { emscriptenOpts: emscriptenOptions }\n  }\n\n  async syncToFs(_relaxedDurability?: boolean) {}\n\n  async initialSyncFs() {}\n\n  async closeFs() {}\n\n  async dumpTar(dbname: string, compression?: DumpTarCompressionOptions) {\n    return dumpTar(this.pg!.Module.FS, PGDATA, dbname, compression)\n  }\n}\n\n/**\n * Abstract base class for all custom virtual filesystems.\n * Each custom filesystem needs to implement an interface similar to the NodeJS FS API.\n */\nexport abstract class BaseFilesystem implements Filesystem {\n  protected dataDir?: string\n  protected pg?: PGlite\n  readonly debug: boolean\n\n  constructor(dataDir?: string, { debug = false }: { debug?: boolean } = {}) {\n    this.dataDir = dataDir\n    this.debug = debug\n  }\n\n  async syncToFs(_relaxedDurability?: boolean) {}\n\n  async initialSyncFs() {}\n\n  async closeFs() {}\n\n  async dumpTar(dbname: string, compression?: DumpTarCompressionOptions) {\n    return dumpTar(this.pg!.Module.FS, PGDATA, dbname, compression)\n  }\n\n  async init(pg: PGlite, emscriptenOptions: Partial<PostgresMod>) {\n    this.pg = pg\n    const options: Partial<PostgresMod> = {\n      ...emscriptenOptions,\n      preRun: [\n        ...(emscriptenOptions.preRun || []),\n        (mod: PostgresMod) => {\n          const EMFS = createEmscriptenFS(mod, this)\n          mod.FS.mkdir(PGDATA)\n          mod.FS.mount(EMFS, {}, PGDATA)\n        },\n      ],\n    }\n    return { emscriptenOpts: options }\n  }\n\n  // Filesystem API\n\n  abstract chmod(path: string, mode: number): void\n  abstract close(fd: number): void\n  abstract fstat(fd: number): FsStats\n  abstract lstat(path: string): FsStats\n  abstract mkdir(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void\n  abstract open(path: string, flags?: string, mode?: number): number\n  abstract readdir(path: string): string[]\n  abstract read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number\n  abstract rename(oldPath: string, newPath: string): void\n  abstract rmdir(path: string): void\n  abstract truncate(\n    path: string,\n    len: number, // Length to truncate to - defaults to 0\n  ): void\n  abstract unlink(path: string): void\n  abstract utimes(path: string, atime: number, mtime: number): void\n  abstract writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void\n  abstract write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number\n}\n\nexport type FsStats = {\n  dev: number\n  ino: number\n  mode: number\n  nlink: number\n  uid: number\n  gid: number\n  rdev: number\n  size: number\n  blksize: number\n  blocks: number\n  atime: number\n  mtime: number\n  ctime: number\n}\n\ntype EmscriptenFileSystem = Emscripten.FileSystemType & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps & {\n    dup: (stream: FSStream) => void\n    mmap: (\n      stream: FSStream,\n      length: number,\n      position: number,\n      prot: any,\n      flags: any,\n    ) => { ptr: number; allocated: boolean }\n    msync: (\n      stream: FSStream,\n      buffer: Uint8Array,\n      offset: number,\n      length: number,\n      mmapFlags: any,\n    ) => number\n  }\n} & { [key: string]: any }\n\ntype FSNode = FS.FSNode & {\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps\n}\n\ntype FSStream = FS.FSStream & {\n  node: FSNode\n  shared: {\n    refcount: number\n  }\n}\n\ntype FSMount = FS.Mount & {\n  opts: {\n    root: string\n  }\n}\n\ntype EmscriptenFS = PostgresMod['FS'] & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n}\n\nexport const ERRNO_CODES = {\n  EBADF: 8,\n  EBADFD: 127,\n  EEXIST: 20,\n  EINVAL: 28,\n  EISDIR: 31,\n  ENODEV: 43,\n  ENOENT: 44,\n  ENOTDIR: 54,\n  ENOTEMPTY: 55,\n} as const\n\n/**\n * Create an emscripten filesystem that uses the BaseFilesystem.\n * @param Module The emscripten module\n * @param baseFS The BaseFilesystem implementation\n * @returns The emscripten filesystem\n */\nconst createEmscriptenFS = (Module: PostgresMod, baseFS: BaseFilesystem) => {\n  const FS = Module.FS as EmscriptenFS\n  const log = baseFS.debug ? console.log : null\n  const EMFS = {\n    tryFSOperation<T>(f: () => T): T {\n      try {\n        return f()\n      } catch (e: any) {\n        if (!e.code) throw e\n        if (e.code === 'UNKNOWN') throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        throw new FS.ErrnoError(e.code)\n      }\n    },\n    mount(_mount: FSMount): FSNode {\n      return EMFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    syncfs(\n      _mount: FS.Mount,\n      _populate: any, // This has the wrong type in @types/emscripten\n      _done: (err?: number | null) => unknown,\n    ): void {\n      // noop\n    },\n    createNode(\n      parent: FSNode | null,\n      name: string,\n      mode: number,\n      _dev?: any,\n    ): FSNode {\n      if (!FS.isDir(mode) && !FS.isFile(mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      const node = FS.createNode(parent, name, mode)\n      node.node_ops = EMFS.node_ops\n      node.stream_ops = EMFS.stream_ops\n      return node\n    },\n    getMode: function (path: string): number {\n      log?.('getMode', path)\n      return EMFS.tryFSOperation(() => {\n        const stats = baseFS.lstat(path)\n        return stats.mode\n      })\n    },\n    realPath: function (node: FSNode): string {\n      const parts: string[] = []\n      while (node.parent !== node) {\n        parts.push(node.name)\n        node = node.parent as FSNode\n      }\n      parts.push((node.mount as FSMount).opts.root)\n      parts.reverse()\n      return parts.join('/')\n    },\n    node_ops: {\n      getattr(node: FSNode): FS.Stats {\n        log?.('getattr', EMFS.realPath(node))\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          const stats = baseFS.lstat(path)\n          return {\n            ...stats,\n            dev: 0,\n            ino: node.id,\n            nlink: 1,\n            rdev: node.rdev,\n            atime: new Date(stats.atime),\n            mtime: new Date(stats.mtime),\n            ctime: new Date(stats.ctime),\n          }\n        })\n      },\n      setattr(node: FSNode, attr: FS.Stats): void {\n        log?.('setattr', EMFS.realPath(node), attr)\n        const path = EMFS.realPath(node)\n        EMFS.tryFSOperation(() => {\n          if (attr.mode !== undefined) {\n            baseFS.chmod(path, attr.mode)\n          }\n          if (attr.size !== undefined) {\n            baseFS.truncate(path, attr.size)\n          }\n          if (attr.timestamp !== undefined) {\n            baseFS.utimes(path, attr.timestamp, attr.timestamp)\n          }\n          if (attr.size !== undefined) {\n            baseFS.truncate(path, attr.size)\n          }\n        })\n      },\n      lookup(parent: FSNode, name: string): FSNode {\n        log?.('lookup', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        const mode = EMFS.getMode(path)\n        return EMFS.createNode(parent, name, mode)\n      },\n      mknod(parent: FSNode, name: string, mode: number, dev: unknown): FSNode {\n        log?.('mknod', EMFS.realPath(parent), name, mode, dev)\n        const node = EMFS.createNode(parent, name, mode, dev)\n        // create the backing node for this in the fs root as well\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          if (FS.isDir(node.mode)) {\n            baseFS.mkdir(path, { mode })\n          } else {\n            baseFS.writeFile(path, '', { mode })\n          }\n          return node\n        })\n      },\n      rename(oldNode: FSNode, newDir: FSNode, newName: string): void {\n        log?.('rename', EMFS.realPath(oldNode), EMFS.realPath(newDir), newName)\n        const oldPath = EMFS.realPath(oldNode)\n        const newPath = [EMFS.realPath(newDir), newName].join('/')\n        EMFS.tryFSOperation(() => {\n          baseFS.rename(oldPath, newPath)\n        })\n        oldNode.name = newName\n      },\n      unlink(parent: FSNode, name: string): void {\n        log?.('unlink', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        try {\n          baseFS.unlink(path)\n        } catch (e: any) {\n          // no-op\n        }\n      },\n      rmdir(parent: FSNode, name: string): void {\n        log?.('rmdir', EMFS.realPath(parent), name)\n        const path = [EMFS.realPath(parent), name].join('/')\n        return EMFS.tryFSOperation(() => {\n          baseFS.rmdir(path)\n        })\n      },\n      readdir(node: FSNode): string[] {\n        log?.('readdir', EMFS.realPath(node))\n        const path = EMFS.realPath(node)\n        return EMFS.tryFSOperation(() => {\n          return baseFS.readdir(path)\n        })\n      },\n      symlink(parent: FSNode, newName: string, oldPath: string): void {\n        log?.('symlink', EMFS.realPath(parent), newName, oldPath)\n        // This is not supported by EMFS\n        throw new FS.ErrnoError(63)\n      },\n      readlink(node: FSNode): string {\n        log?.('readlink', EMFS.realPath(node))\n        // This is not supported by EMFS\n        throw new FS.ErrnoError(63)\n      },\n    },\n    stream_ops: {\n      open(stream: FSStream): void {\n        log?.('open stream', EMFS.realPath(stream.node))\n        const path = EMFS.realPath(stream.node)\n        return EMFS.tryFSOperation(() => {\n          if (FS.isFile(stream.node.mode)) {\n            stream.shared.refcount = 1\n            stream.nfd = baseFS.open(path)\n          }\n        })\n      },\n      close(stream: FSStream): void {\n        log?.('close stream', EMFS.realPath(stream.node))\n        return EMFS.tryFSOperation(() => {\n          if (\n            FS.isFile(stream.node.mode) &&\n            stream.nfd &&\n            --stream.shared.refcount === 0\n          ) {\n            baseFS.close(stream.nfd)\n          }\n        })\n      },\n      dup(stream: FSStream) {\n        log?.('dup stream', EMFS.realPath(stream.node))\n        stream.shared.refcount++\n      },\n      read(\n        stream: FSStream, // Stream to read from\n        buffer: Uint8Array, // Buffer to read into - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing to\n        length: number, // Number of bytes to read\n        position: number, // Position in file to read from\n      ): number {\n        log?.(\n          'read stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        if (length === 0) return 0\n        const ret = EMFS.tryFSOperation(() =>\n          baseFS.read(\n            stream.nfd!,\n            buffer as unknown as Uint8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n        return ret\n      },\n      write(\n        stream: FSStream, // Stream to write to\n        buffer: Uint8Array, // Buffer to read from - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing from\n        length: number, // Number of bytes to write\n        position: number, // Position in file to write to\n      ): number {\n        log?.(\n          'write stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        return EMFS.tryFSOperation(() =>\n          baseFS.write(\n            stream.nfd!,\n            buffer.buffer as unknown as Uint8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n      },\n      llseek(stream: FSStream, offset: number, whence: number): number {\n        log?.('llseek stream', EMFS.realPath(stream.node), offset, whence)\n        let position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            EMFS.tryFSOperation(() => {\n              const stat = baseFS.fstat(stream.nfd!)\n              position += stat.size\n            })\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      mmap(\n        stream: FSStream,\n        length: number,\n        position: number,\n        prot: any,\n        flags: any,\n      ) {\n        log?.(\n          'mmap stream',\n          EMFS.realPath(stream.node),\n          length,\n          position,\n          prot,\n          flags,\n        )\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n\n        const ptr = (Module as any).mmapAlloc(length) // TODO: Fix type and check this is exported\n\n        EMFS.stream_ops.read(\n          stream,\n          Module.HEAP8 as unknown as Uint8Array,\n          ptr,\n          length,\n          position,\n        )\n        return { ptr, allocated: true }\n      },\n      msync(\n        stream: FSStream,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        mmapFlags: any,\n      ) {\n        log?.(\n          'msync stream',\n          EMFS.realPath(stream.node),\n          offset,\n          length,\n          mmapFlags,\n        )\n        EMFS.stream_ops.write(stream, buffer, 0, length, offset)\n        return 0\n      },\n    },\n  } satisfies EmscriptenFileSystem\n  return EMFS\n}\n","import { tar, untar, type TarFile, REGTYPE, DIRTYPE } from 'tinytar'\nimport type { FS } from '../postgresMod.js'\n\nexport type DumpTarCompressionOptions = 'none' | 'gzip' | 'auto'\n\nexport async function dumpTar(\n  FS: FS,\n  pgDataDir: string,\n  dbname: string = 'pgdata',\n  compression: DumpTarCompressionOptions = 'auto',\n): Promise<File | Blob> {\n  const tarball = createTarball(FS, pgDataDir)\n  const [compressed, zipped] = await maybeZip(tarball, compression)\n  const filename = dbname + (zipped ? '.tar.gz' : '.tar')\n  const type = zipped ? 'application/x-gzip' : 'application/x-tar'\n  if (typeof File !== 'undefined') {\n    return new File([compressed], filename, {\n      type,\n    })\n  } else {\n    return new Blob([compressed], {\n      type,\n    })\n  }\n}\n\nconst compressedMimeTypes = [\n  'application/x-gtar',\n  'application/x-tar+gzip',\n  'application/x-gzip',\n  'application/gzip',\n]\n\nexport async function loadTar(\n  FS: FS,\n  file: File | Blob,\n  pgDataDir: string,\n): Promise<void> {\n  let tarball = new Uint8Array(await file.arrayBuffer())\n  const filename =\n    typeof File !== 'undefined' && file instanceof File ? file.name : undefined\n  const compressed =\n    compressedMimeTypes.includes(file.type) ||\n    filename?.endsWith('.tgz') ||\n    filename?.endsWith('.tar.gz')\n  if (compressed) {\n    tarball = await unzip(tarball)\n  }\n\n  const files = untar(tarball)\n  for (const file of files) {\n    const filePath = pgDataDir + file.name\n\n    // Ensure the directory structure exists\n    const dirPath = filePath.split('/').slice(0, -1)\n    for (let i = 1; i <= dirPath.length; i++) {\n      const dir = dirPath.slice(0, i).join('/')\n      if (!FS.analyzePath(dir).exists) {\n        FS.mkdir(dir)\n      }\n    }\n\n    // Write the file or directory\n    if (file.type === REGTYPE) {\n      FS.writeFile(filePath, file.data)\n      FS.utime(\n        filePath,\n        dateToUnixTimestamp(file.modifyTime),\n        dateToUnixTimestamp(file.modifyTime),\n      )\n    } else if (file.type === DIRTYPE) {\n      FS.mkdir(filePath)\n    }\n  }\n}\n\nfunction readDirectory(FS: FS, path: string) {\n  const files: TarFile[] = []\n\n  const traverseDirectory = (currentPath: string) => {\n    const entries = FS.readdir(currentPath)\n    entries.forEach((entry) => {\n      if (entry === '.' || entry === '..') {\n        return\n      }\n      const fullPath = currentPath + '/' + entry\n      const stats = FS.stat(fullPath)\n      const data = FS.isFile(stats.mode)\n        ? FS.readFile(fullPath, { encoding: 'binary' })\n        : new Uint8Array(0)\n      files.push({\n        name: fullPath.substring(path.length), // remove the root path\n        mode: stats.mode,\n        size: stats.size,\n        type: FS.isFile(stats.mode) ? REGTYPE : DIRTYPE,\n        modifyTime: stats.mtime,\n        data,\n      })\n      if (FS.isDir(stats.mode)) {\n        traverseDirectory(fullPath)\n      }\n    })\n  }\n\n  traverseDirectory(path)\n  return files\n}\n\nexport function createTarball(FS: FS, directoryPath: string) {\n  const files = readDirectory(FS, directoryPath)\n  const tarball = tar(files)\n  return tarball\n}\n\nexport async function maybeZip(\n  file: Uint8Array,\n  compression: DumpTarCompressionOptions = 'auto',\n): Promise<[Uint8Array, boolean]> {\n  if (compression === 'none') {\n    return [file, false]\n  } else if (typeof CompressionStream !== 'undefined') {\n    return [await zipBrowser(file), true]\n  } else if (\n    typeof process !== 'undefined' &&\n    process.versions &&\n    process.versions.node\n  ) {\n    return [await zipNode(file), true]\n  } else if (compression === 'auto') {\n    return [file, false]\n  } else {\n    throw new Error('Compression not supported in this environment')\n  }\n}\n\nexport async function zipBrowser(file: Uint8Array): Promise<Uint8Array> {\n  const cs = new CompressionStream('gzip')\n  const writer = cs.writable.getWriter()\n  const reader = cs.readable.getReader()\n\n  writer.write(file)\n  writer.close()\n\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { value, done } = await reader.read()\n    if (done) break\n    if (value) chunks.push(value)\n  }\n\n  const compressed = new Uint8Array(\n    chunks.reduce((acc, chunk) => acc + chunk.length, 0),\n  )\n  let offset = 0\n  chunks.forEach((chunk) => {\n    compressed.set(chunk, offset)\n    offset += chunk.length\n  })\n\n  return compressed\n}\n\nexport async function zipNode(file: Uint8Array): Promise<Uint8Array> {\n  const { promisify } = await import('util')\n  const { gzip } = await import('zlib')\n  const gzipPromise = promisify(gzip)\n  return await gzipPromise(file)\n}\n\nexport async function unzip(file: Uint8Array): Promise<Uint8Array> {\n  if (typeof CompressionStream !== 'undefined') {\n    return await unzipBrowser(file)\n  } else if (\n    typeof process !== 'undefined' &&\n    process.versions &&\n    process.versions.node\n  ) {\n    return await unzipNode(file)\n  } else {\n    throw new Error('Unsupported environment for decompression')\n  }\n}\n\nexport async function unzipBrowser(file: Uint8Array): Promise<Uint8Array> {\n  const ds = new DecompressionStream('gzip')\n  const writer = ds.writable.getWriter()\n  const reader = ds.readable.getReader()\n\n  writer.write(file)\n  writer.close()\n\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { value, done } = await reader.read()\n    if (done) break\n    if (value) chunks.push(value)\n  }\n\n  const decompressed = new Uint8Array(\n    chunks.reduce((acc, chunk) => acc + chunk.length, 0),\n  )\n  let offset = 0\n  chunks.forEach((chunk) => {\n    decompressed.set(chunk, offset)\n    offset += chunk.length\n  })\n\n  return decompressed\n}\n\nexport async function unzipNode(file: Uint8Array): Promise<Uint8Array> {\n  const { promisify } = await import('util')\n  const { gunzip } = await import('zlib')\n  const gunzipPromise = promisify(gunzip)\n  return await gunzipPromise(file)\n}\n\nfunction dateToUnixTimestamp(date: Date | number | undefined): number {\n  if (!date) {\n    return Math.floor(Date.now() / 1000)\n  } else {\n    return typeof date === 'number' ? date : Math.floor(date.getTime() / 1000)\n  }\n}\n"],"mappings":"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","names":["exports","module","undefined","array","exports","module","exports","module","exports","module","field","value","i","tar","exports","module","error","untar","exports","module","tar","untar","node"]}