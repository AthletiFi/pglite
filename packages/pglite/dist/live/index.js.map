{"version":3,"sources":["../../src/live/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from '../interface'\nimport type {\n  LiveQueryOptions,\n  LiveIncrementalQueryOptions,\n  LiveChangesOptions,\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n} from './interface'\nimport { uuid, formatQuery } from '../utils.js'\n\nexport type {\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n} from './interface.js'\n\nconst MAX_RETRIES = 5\n\nconst setup = async (pg: PGliteInterface, _emscriptenOpts: any) => {\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>()\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string | LiveQueryOptions<T>,\n      params?: any[] | null,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        callback = query.callback\n        query = query.query\n      }\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let results: Results<T>\n      let tables: { table_name: string; schema_name: string }[]\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Create prepared statement to get the results\n          await tx.exec(`\n            PREPARE live_query_${id}_get AS\n            SELECT * FROM live_query_${id}_view;\n          `)\n\n          // Get the initial results\n          results = await tx.query<T>(`EXECUTE live_query_${id}_get;`)\n        })\n      }\n      await init()\n\n      // Function to refresh the query\n      const refresh = async (count = 0) => {\n        if (callbacks.length === 0) {\n          return\n        }\n        try {\n          results = await pg.query<T>(`EXECUTE live_query_${id}_get;`)\n        } catch (e) {\n          const msg = (e as Error).message\n          if (\n            msg === `prepared statement \"live_query_${id}_get\" does not exist`\n          ) {\n            // If the prepared statement does not exist, reset and try again\n            // This can happen if using the multi-tab worker\n            if (count > MAX_RETRIES) {\n              throw e\n            }\n            await init()\n            refresh(count + 1)\n          } else {\n            throw e\n          }\n        }\n        runResultCallbacks(callbacks, results)\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => {\n              refresh()\n            },\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      // If no function is provided, unsubscribe all callbacks\n      // If there are no callbacks, unsubscribe from the notify triggers\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DEALLOCATE live_query_${id}_get;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial results\n      runResultCallbacks(callbacks, results!)\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n\n    async changes<T>(\n      query: string | LiveChangesOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (changes: Array<Change<T>>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for changes queries')\n      }\n      let callbacks: Array<(changes: Array<Change<T>>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let tables: { table_name: string; schema_name: string }[]\n      let stateSwitch: 1 | 2 = 1\n      let changes: Results<Change<T>>\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Get the columns of the view\n          const columns = [\n            ...(\n              await tx.query<any>(`\n                SELECT column_name, data_type, udt_name\n                FROM information_schema.columns \n                WHERE table_name = 'live_query_${id}_view'\n              `)\n            ).rows,\n            { column_name: '__after__', data_type: 'integer' },\n          ]\n\n          // Init state tables as empty temp table\n          await tx.exec(`\n            CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n            CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n          `)\n\n          // Create Diff views and prepared statements\n          for (const curr of [1, 2]) {\n            const prev = curr === 1 ? 2 : 1\n            await tx.exec(`\n              PREPARE live_query_${id}_diff${curr} AS\n              WITH\n                prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n                curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n                data_diff AS (\n                  -- INSERT operations: Include all columns\n                  SELECT \n                    'INSERT' AS __op__,\n                    ${columns\n                      .map(\n                        ({ column_name }) =>\n                          `curr.\"${column_name}\" AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                    ARRAY[]::text[] AS __changed_columns__\n                  FROM curr\n                  LEFT JOIN prev ON curr.${key} = prev.${key}\n                  WHERE prev.${key} IS NULL\n                UNION ALL\n                  -- DELETE operations: Include only the primary key\n                  SELECT \n                    'DELETE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) => {\n                        if (column_name === key) {\n                          return `prev.\"${column_name}\" AS \"${column_name}\"`\n                        } else {\n                          return `NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``} AS \"${column_name}\"`\n                        }\n                      })\n                      .join(',\\n')},\n                      ARRAY[]::text[] AS __changed_columns__\n                  FROM prev\n                  LEFT JOIN curr ON prev.${key} = curr.${key}\n                  WHERE curr.${key} IS NULL\n                UNION ALL\n                  -- UPDATE operations: Include only changed columns\n                  SELECT \n                    'UPDATE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) =>\n                        column_name === key\n                          ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                          : `CASE \n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN curr.\"${column_name}\"\n                              ELSE NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``}\n                              END AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                      ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                        .filter(({ column_name }) => column_name !== key)\n                        .map(\n                          ({ column_name }) =>\n                            `CASE\n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN '${column_name}' \n                              ELSE NULL \n                              END`,\n                        )\n                        .join(\n                          ', ',\n                        )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                  FROM curr\n                  INNER JOIN prev ON curr.${key} = prev.${key}\n                  WHERE NOT (curr IS NOT DISTINCT FROM prev)\n                )\n              SELECT * FROM data_diff;\n            `)\n          }\n        })\n      }\n\n      await init()\n\n      const refresh = async () => {\n        if (callbacks.length === 0 && changes) {\n          return\n        }\n        let reset = false\n        for (let i = 0; i < 5; i++) {\n          try {\n            await pg.transaction(async (tx) => {\n              // Populate the state table\n              await tx.exec(`\n                INSERT INTO live_query_${id}_state${stateSwitch} \n                  SELECT * FROM live_query_${id}_view;\n              `)\n\n              // Get the changes\n              changes = await tx.query<any>(\n                `EXECUTE live_query_${id}_diff${stateSwitch};`,\n              )\n\n              // Switch state\n              stateSwitch = stateSwitch === 1 ? 2 : 1\n\n              // Truncate the old state table\n              await tx.exec(`\n                TRUNCATE live_query_${id}_state${stateSwitch};\n              `)\n            })\n            break\n          } catch (e) {\n            const msg = (e as Error).message\n            if (\n              msg ===\n              `relation \"live_query_${id}_state${stateSwitch}\" does not exist`\n            ) {\n              // If the state table does not exist, reset and try again\n              // This can happen if using the multi-tab worker\n              reset = true\n              await init()\n              continue\n            } else {\n              throw e\n            }\n          }\n        }\n\n        runChangeCallbacks(callbacks, [\n          ...(reset\n            ? [\n                {\n                  __op__: 'RESET' as const,\n                },\n              ]\n            : []),\n          ...changes!.rows,\n        ])\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => refresh(),\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (changes: Array<Change<T>>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async (\n        callback?: (changes: Array<Change<T>>) => void,\n      ) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DROP TABLE IF EXISTS live_query_${id}_state1;\n            DROP TABLE IF EXISTS live_query_${id}_state2;\n            DEALLOCATE live_query_${id}_diff1;\n            DEALLOCATE live_query_${id}_diff2;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial changes\n      await refresh()\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          !['__after__', '__op__', '__changed_columns__'].includes(field.name),\n      )\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChanges<T>\n    },\n\n    async incrementalQuery<T>(\n      query: string | LiveIncrementalQueryOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for incremental queries')\n      }\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const rowsMap: Map<any, any> = new Map()\n      const afterMap: Map<any, any> = new Map()\n      let lastRows: T[] = []\n      let firstRun = true\n\n      const {\n        fields,\n        unsubscribe: unsubscribeChanges,\n        refresh,\n      } = await namespaceObj.changes<T>(query, params, key, (changes) => {\n        // Process the changes\n        for (const change of changes) {\n          const {\n            __op__: op,\n            __changed_columns__: changedColumns,\n            ...obj\n          } = change as typeof change & { [key: string]: any }\n          switch (op) {\n            case 'RESET':\n              rowsMap.clear()\n              afterMap.clear()\n              break\n            case 'INSERT':\n              rowsMap.set(obj[key], obj)\n              afterMap.set(obj.__after__, obj[key])\n              break\n            case 'DELETE': {\n              const oldObj = rowsMap.get(obj[key])\n              rowsMap.delete(obj[key])\n              // null is the starting point, we don't delete it as another insert\n              // may have happened thats replacing it\n              if (oldObj.__after__ !== null) {\n                afterMap.delete(oldObj.__after__)\n              }\n              break\n            }\n            case 'UPDATE': {\n              const newObj = { ...(rowsMap.get(obj[key]) ?? {}) }\n              for (const columnName of changedColumns) {\n                newObj[columnName] = obj[columnName]\n                if (columnName === '__after__') {\n                  afterMap.set(obj.__after__, obj[key])\n                }\n              }\n              rowsMap.set(obj[key], newObj)\n              break\n            }\n          }\n        }\n\n        // Get the rows in order\n        const rows: T[] = []\n        let lastKey: any = null\n        for (let i = 0; i < rowsMap.size; i++) {\n          const nextKey = afterMap.get(lastKey)\n          const obj = rowsMap.get(nextKey)\n          if (!obj) {\n            break\n          }\n          // Remove the __after__ key from the exposed row\n          const cleanObj = { ...obj }\n          delete cleanObj.__after__\n          rows.push(cleanObj)\n          lastKey = nextKey\n        }\n        lastRows = rows\n\n        // Run the callbacks\n        if (!firstRun) {\n          runResultCallbacks(callbacks, {\n            rows,\n            fields,\n          })\n        }\n      })\n\n      firstRun = false\n      runResultCallbacks(callbacks, {\n        rows: lastRows,\n        fields,\n      })\n\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        callbacks.push(callback)\n      }\n\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          await unsubscribeChanges()\n        }\n      }\n\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n  }\n\n  return {\n    namespaceObj,\n  }\n}\n\nexport const live = {\n  name: 'Live Queries',\n  setup,\n} satisfies Extension\n\nexport type PGliteWithLive = PGliteInterface & {\n  live: LiveNamespace\n}\n\n/**\n * Get a list of all the tables used in a view, recursively\n * @param tx a transaction or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string,\n): Promise<{ table_name: string; schema_name: string }[]> {\n  const tables = new Map<string, { table_name: string; schema_name: string }>()\n\n  async function getTablesRecursive(currentViewName: string) {\n    const result = await tx.query<{\n      table_name: string\n      schema_name: string\n      is_view: boolean\n    }>(\n      `\n        SELECT DISTINCT\n          cl.relname AS table_name,\n          n.nspname AS schema_name,\n          cl.relkind = 'v' AS is_view\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n        r.ev_class = (\n            SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n        )\n        AND d.deptype = 'n';\n      `,\n      [currentViewName],\n    )\n\n    for (const row of result.rows) {\n      if (row.table_name !== currentViewName && !row.is_view) {\n        const tableKey = `\"${row.schema_name}\".\"${row.table_name}\"`\n        if (!tables.has(tableKey)) {\n          tables.set(tableKey, {\n            table_name: row.table_name,\n            schema_name: row.schema_name,\n          })\n        }\n      } else if (row.is_view) {\n        await getTablesRecursive(row.table_name)\n      }\n    }\n  }\n\n  await getTablesRecursive(viewName)\n\n  return Array.from(tables.values())\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>,\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`,\n        ),\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER \"_notify_trigger_${table.schema_name}_${table.table_name}\"\n      AFTER INSERT OR UPDATE OR DELETE ON \"${table.schema_name}\".\"${table.table_name}\"\n      FOR EACH STATEMENT EXECUTE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"();\n      `\n    })\n    .join('\\n')\n  if (triggers.trim() !== '') {\n    await tx.exec(triggers)\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`),\n  )\n}\n\nconst runResultCallbacks = <T>(\n  callbacks: Array<(results: Results<T>) => void>,\n  results: Results<T>,\n) => {\n  for (const callback of callbacks) {\n    callback(results)\n  }\n}\n\nconst runChangeCallbacks = <T>(\n  callbacks: Array<(changes: Array<Change<T>>) => void>,\n  changes: Array<Change<T>>,\n) => {\n  for (const callback of callbacks) {\n    callback(changes)\n  }\n}\n"],"mappings":"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","names":["callback"]}