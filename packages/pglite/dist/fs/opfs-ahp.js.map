{"version":3,"sources":["../../src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"mappings":"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","names":["node"]}