{"version":3,"sources":["../src/base.ts"],"sourcesContent":["import { query as queryTemplate } from './templating.js'\nimport { parseDescribeStatementResults, parseResults } from './parse.js'\nimport {\n  type Serializer,\n  type Parser,\n  serializers,\n  parsers,\n  arraySerializer,\n  arrayParser,\n} from './types.js'\nimport type {\n  DebugLevel,\n  PGliteInterface,\n  Results,\n  Transaction,\n  QueryOptions,\n  ExecProtocolOptions,\n  ExecProtocolResult,\n} from './interface.js'\n\nimport { serialize as serializeProtocol } from '@electric-sql/pg-protocol'\n\nexport abstract class BasePGlite\n  implements Pick<PGliteInterface, 'query' | 'sql' | 'exec' | 'transaction'>\n{\n  serializers: Record<number | string, Serializer> = { ...serializers }\n  parsers: Record<number | string, Parser> = { ...parsers }\n  #arrayTypesInitialized = false\n\n  // # Abstract properties:\n  abstract debug: DebugLevel\n\n  // # Private properties:\n  #inTransaction = false\n\n  // # Abstract methods:\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  abstract execProtocol(\n    message: Uint8Array,\n    { syncToFs, onNotice }: ExecProtocolOptions,\n  ): Promise<ExecProtocolResult>\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  abstract execProtocolRaw(\n    message: Uint8Array,\n    { syncToFs }: ExecProtocolOptions,\n  ): Promise<Uint8Array>\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  abstract syncToFs(): Promise<void>\n\n  /**\n   * Handle a file attached to the current query\n   * @param file The file to handle\n   */\n  abstract _handleBlob(blob?: File | Blob): Promise<void>\n\n  /**\n   * Get the written file\n   */\n  abstract _getWrittenBlob(): Promise<File | Blob | undefined>\n\n  /**\n   * Cleanup the current file\n   */\n  abstract _cleanupBlob(): Promise<void>\n\n  abstract _checkReady(): Promise<void>\n  abstract _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T>\n  abstract _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T>\n\n  // # Concrete implementations:\n\n  /**\n   * Initialize the array types\n   * The oid if the type of an element and the typarray is the oid of the type of the\n   * array.\n   * We extract these from the databaes then create the serializers/parsers for\n   * each type.\n   * This should be called at the end of #init() in the implementing class.\n   */\n  async _initArrayTypes() {\n    if (this.#arrayTypesInitialized) return\n    this.#arrayTypesInitialized = true\n\n    const types = await this.query<{ oid: number; typarray: number }>(`\n      SELECT b.oid, b.typarray\n      FROM pg_catalog.pg_type a\n      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem\n      WHERE a.typcategory = 'A'\n      GROUP BY b.oid, b.typarray\n      ORDER BY b.oid\n    `)\n\n    for (const type of types.rows) {\n      this.serializers[type.typarray] = (x) =>\n        arraySerializer(x, this.serializers[type.oid], type.typarray)\n      this.parsers[type.typarray] = (x) =>\n        arrayParser(x, this.parsers[type.oid], type.typarray)\n    }\n  }\n\n  async #execProtocolNoSync(\n    message: Uint8Array,\n    options: ExecProtocolOptions = {},\n  ): Promise<ExecProtocolResult> {\n    return await this.execProtocol(message, { ...options, syncToFs: false })\n  }\n\n  /**\n   * Execute a single SQL statement\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    await this._checkReady()\n    // We wrap the public query method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runQuery<T>(query, params, options)\n    })\n  }\n\n  /**\n   * Execute a single SQL statement like with {@link PGlite.query}, but with a\n   * templated statement where template values will be treated as parameters.\n   *\n   * You can use helpers from `/template` to further format the query with\n   * identifiers, raw SQL, and nested statements.\n   *\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   *\n   * @param query The query to execute with parameters as template values\n   * @returns The result of the query\n   *\n   * @example\n   * ```ts\n   * const results = await db.sql`SELECT * FROM ${identifier`foo`} WHERE id = ${id}`\n   * ```\n   */\n  async sql<T>(\n    sqlStrings: TemplateStringsArray,\n    ...params: any[]\n  ): Promise<Results<T>> {\n    const { query, params: actualParams } = queryTemplate(sqlStrings, ...params)\n    return await this.query(query, actualParams)\n  }\n\n  /**\n   * Execute a SQL query, this can have multiple statements.\n   * This uses the \"Simple Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @returns The result of the query\n   */\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    await this._checkReady()\n    // We wrap the public exec method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runExec(query, options)\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runQuery<T>(\n    query: string,\n    params: any[] = [],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    return await this._runExclusiveQuery(async () => {\n      // We need to parse, bind and execute a query with parameters\n      this.#log('runQuery', query, params, options)\n      await this._handleBlob(options?.blob)\n\n      let results\n\n      try {\n        const { messages: parseResults } = await this.#execProtocolNoSync(\n          serializeProtocol.parse({ text: query, types: options?.paramTypes }),\n          options,\n        )\n\n        const dataTypeIDs = parseDescribeStatementResults(\n          (\n            await this.#execProtocolNoSync(\n              serializeProtocol.describe({ type: 'S' }),\n              options,\n            )\n          ).messages,\n        )\n\n        const values = params.map((param, i) => {\n          const oid = dataTypeIDs[i]\n          if (param === null || param === undefined) {\n            return null\n          }\n          const serialize = this.serializers[oid]\n          if (serialize) {\n            return serialize(param)\n          } else {\n            return param.toString()\n          }\n        })\n\n        results = [\n          ...parseResults,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.bind({\n                values,\n              }),\n              options,\n            )\n          ).messages,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.describe({ type: 'P' }),\n              options,\n            )\n          ).messages,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.execute({}),\n              options,\n            )\n          ).messages,\n        ]\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n\n      await this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(results, this.parsers, options, blob)[0] as Results<T>\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runExec(\n    query: string,\n    options?: QueryOptions,\n  ): Promise<Array<Results>> {\n    return await this._runExclusiveQuery(async () => {\n      // No params so we can just send the query\n      this.#log('runExec', query, options)\n      await this._handleBlob(options?.blob)\n      let results\n      try {\n        results = (\n          await this.#execProtocolNoSync(\n            serializeProtocol.query(query),\n            options,\n          )\n        ).messages\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n      this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(\n        results,\n        this.parsers,\n        options,\n        blob,\n      ) as Array<Results>\n    })\n  }\n\n  /**\n   * Execute a transaction\n   * @param callback A callback function that takes a transaction object\n   * @returns The result of the transaction\n   */\n  async transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined> {\n    await this._checkReady()\n    return await this._runExclusiveTransaction(async () => {\n      await this.#runExec('BEGIN')\n      this.#inTransaction = true\n\n      // Once a transaction is closed, we throw an error if it's used again\n      let closed = false\n      const checkClosed = () => {\n        if (closed) {\n          throw new Error('Transaction is closed')\n        }\n      }\n\n      const tx: Transaction = {\n        query: async <T>(\n          query: string,\n          params?: any[],\n          options?: QueryOptions,\n        ): Promise<Results<T>> => {\n          checkClosed()\n          return await this.#runQuery(query, params, options)\n        },\n        sql: async <T>(\n          sqlStrings: TemplateStringsArray,\n          ...params: any[]\n        ): Promise<Results<T>> => {\n          const { query, params: actualParams } = queryTemplate(\n            sqlStrings,\n            ...params,\n          )\n          return await this.#runQuery(query, actualParams)\n        },\n        exec: async (\n          query: string,\n          options?: QueryOptions,\n        ): Promise<Array<Results>> => {\n          checkClosed()\n          return await this.#runExec(query, options)\n        },\n        rollback: async () => {\n          checkClosed()\n          // Rollback and set the closed flag to prevent further use of this\n          // transaction\n          await this.#runExec('ROLLBACK')\n          closed = true\n        },\n        get closed() {\n          return closed\n        },\n      }\n\n      try {\n        const result = await callback(tx)\n        if (!closed) {\n          closed = true\n          await this.#runExec('COMMIT')\n        }\n        this.#inTransaction = false\n        return result\n      } catch (e) {\n        if (!closed) {\n          await this.#runExec('ROLLBACK')\n        }\n        this.#inTransaction = false\n        throw e\n      }\n    })\n  }\n\n  /**\n   * Internal log function\n   */\n  #log(...args: any[]) {\n    if (this.debug > 0) {\n      console.log(...args)\n    }\n  }\n}\n"],"mappings":"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","names":["query","parseResults","serialize"]}