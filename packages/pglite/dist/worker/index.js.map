{"version":3,"sources":["../../src/worker/index.ts"],"sourcesContent":["import type {\n  DebugLevel,\n  ExecProtocolResult,\n  Extensions,\n  PGliteInterface,\n  PGliteInterfaceExtensions,\n  PGliteOptions,\n} from '../interface.js'\nimport type { PGlite } from '../pglite.js'\nimport { BasePGlite } from '../base.js'\nimport { uuid } from '../utils.js'\n\nexport type PGliteWorkerOptions = PGliteOptions & {\n  meta?: any\n  id?: string\n}\n\nexport class PGliteWorker\n  extends BasePGlite\n  implements PGliteInterface, AsyncDisposable\n{\n  #initPromise: Promise<void>\n  #debug: DebugLevel = 0\n\n  #ready = false\n  #closed = false\n  #isLeader = false\n\n  #eventTarget = new EventTarget()\n\n  #tabId: string\n\n  #connected = false\n\n  #workerProcess: Worker\n  #workerID?: string\n  #workerHerePromise?: Promise<void>\n  #workerReadyPromise?: Promise<void>\n\n  #broadcastChannel?: BroadcastChannel\n  #tabChannel?: BroadcastChannel\n  #releaseTabCloseLock?: () => void\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>()\n  #globalNotifyListeners = new Set<(channel: string, payload: string) => void>()\n\n  #extensions: Extensions\n  #extensionsClose: Array<() => Promise<void>> = []\n\n  constructor(worker: Worker, options?: PGliteWorkerOptions) {\n    super()\n    this.#workerProcess = worker\n    this.#tabId = uuid()\n    this.#extensions = options?.extensions ?? {}\n\n    this.#workerHerePromise = new Promise<void>((resolve) => {\n      this.#workerProcess.addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'here') {\n            resolve()\n          } else {\n            throw new Error('Invalid message')\n          }\n        },\n        { once: true },\n      )\n    })\n\n    this.#workerReadyPromise = new Promise<void>((resolve) => {\n      const callback = (event: MessageEvent<any>) => {\n        if (event.data.type === 'ready') {\n          this.#workerID = event.data.id\n          this.#workerProcess.removeEventListener('message', callback)\n          resolve()\n        }\n      }\n      this.#workerProcess.addEventListener('message', callback)\n    })\n\n    this.#initPromise = this.#init(options)\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * This also awaits the instance to be ready before resolving\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param worker The worker to use\n   * @param options Optional options\n   * @returns A promise that resolves to the PGlite instance when it's ready.\n   */\n  static async create<O extends PGliteWorkerOptions>(\n    worker: Worker,\n    options?: O,\n  ): Promise<PGliteWorker & PGliteInterfaceExtensions<O['extensions']>> {\n    const pg = new PGliteWorker(worker, options)\n    await pg.#initPromise\n    return pg as PGliteWorker & PGliteInterfaceExtensions<O['extensions']>\n  }\n\n  async #init(options: PGliteWorkerOptions = {}) {\n    // Setup the extensions\n    for (const [extName, ext] of Object.entries(this.#extensions)) {\n      if (ext instanceof URL) {\n        throw new Error(\n          'URL extensions are not supported on the client side of a worker',\n        )\n      } else {\n        const extRet = await ext.setup(this, {}, true)\n        if (extRet.emscriptenOpts) {\n          console.warn(\n            `PGlite extension ${extName} returned emscriptenOpts, these are not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.namespaceObj) {\n          const instance = this as any\n          instance[extName] = extRet.namespaceObj\n        }\n        if (extRet.bundlePath) {\n          console.warn(\n            `PGlite extension ${extName} returned bundlePath, this is not supported on the client side of a worker`,\n          )\n        }\n        if (extRet.init) {\n          await extRet.init()\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close)\n        }\n      }\n    }\n\n    // Wait for the worker let us know it's here\n    await this.#workerHerePromise\n\n    // Send the worker the options\n    const { extensions: _, ...workerOptions } = options\n    this.#workerProcess.postMessage({\n      type: 'init',\n      options: workerOptions,\n    })\n\n    // Wait for the worker let us know it's ready\n    await this.#workerReadyPromise\n\n    // Acquire the tab close lock, this is released then the tab, or this\n    // PGliteWorker instance, is closed\n    const tabCloseLockId = `pglite-tab-close:${this.#tabId}`\n    this.#releaseTabCloseLock = await acquireLock(tabCloseLockId)\n\n    // Start the broadcast channel used to communicate with tabs and leader election\n    const broadcastChannelId = `pglite-broadcast:${this.#workerID}`\n    this.#broadcastChannel = new BroadcastChannel(broadcastChannelId)\n\n    // Start the tab channel used to communicate with the leader directly\n    const tabChannelId = `pglite-tab:${this.#tabId}`\n    this.#tabChannel = new BroadcastChannel(tabChannelId)\n\n    this.#broadcastChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-here') {\n        this.#connected = false\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n        this.#leaderNotifyLoop()\n      } else if (event.data.type === 'notify') {\n        this.#receiveNotification(event.data.channel, event.data.payload)\n      }\n    })\n\n    this.#tabChannel.addEventListener('message', async (event) => {\n      if (event.data.type === 'connected') {\n        this.#connected = true\n        this.#eventTarget.dispatchEvent(new Event('connected'))\n        this.#debug = await this.#rpc('getDebugLevel')\n        this.#ready = true\n      }\n    })\n\n    this.#workerProcess.addEventListener('message', async (event) => {\n      if (event.data.type === 'leader-now') {\n        this.#isLeader = true\n        this.#eventTarget.dispatchEvent(new Event('leader-change'))\n      }\n    })\n\n    this.#leaderNotifyLoop()\n\n    // Init array types\n    // We don't await this as it will result in a deadlock\n    // It immediately takes out the transaction lock as so another query\n    this._initArrayTypes()\n  }\n\n  async #leaderNotifyLoop() {\n    if (!this.#connected) {\n      this.#broadcastChannel!.postMessage({\n        type: 'tab-here',\n        id: this.#tabId,\n      })\n      setTimeout(() => this.#leaderNotifyLoop(), 16)\n    }\n  }\n\n  async #rpc<Method extends WorkerRpcMethod>(\n    method: Method,\n    ...args: Parameters<WorkerApi[Method]>\n  ): Promise<ReturnType<WorkerApi[Method]>> {\n    const callId = uuid()\n    const message: WorkerRpcCall<Method> = {\n      type: 'rpc-call',\n      callId,\n      method,\n      args,\n    }\n    this.#tabChannel!.postMessage(message)\n    return await new Promise<ReturnType<WorkerApi[Method]>>(\n      (resolve, reject) => {\n        const listener = (event: MessageEvent) => {\n          if (event.data.callId !== callId) return\n          cleanup()\n          const message: WorkerRpcResponse<Method> = event.data\n          if (message.type === 'rpc-return') {\n            resolve(message.result)\n          } else if (message.type === 'rpc-error') {\n            const error = new Error(message.error.message)\n            Object.assign(error, message.error)\n            reject(error)\n          } else {\n            reject(new Error('Invalid message'))\n          }\n        }\n        const leaderChangeListener = () => {\n          // If the leader changes, throw an error to reject the promise\n          cleanup()\n          reject(new LeaderChangedError())\n        }\n        const cleanup = () => {\n          this.#tabChannel!.removeEventListener('message', listener)\n          this.#eventTarget.removeEventListener(\n            'leader-change',\n            leaderChangeListener,\n          )\n        }\n        this.#eventTarget.addEventListener(\n          'leader-change',\n          leaderChangeListener,\n        )\n        this.#tabChannel!.addEventListener('message', listener)\n      },\n    )\n  }\n\n  get waitReady() {\n    return new Promise<void>((resolve) => {\n      this.#initPromise.then(() => {\n        if (!this.#connected) {\n          resolve(\n            new Promise<void>((resolve) => {\n              this.#eventTarget.addEventListener('connected', () => {\n                resolve()\n              })\n            }),\n          )\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  get debug() {\n    return this.#debug\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed\n  }\n\n  /**\n   * The leader state of this tab\n   */\n  get isLeader() {\n    return this.#isLeader\n  }\n\n  /**\n   * Close the database\n   * @returns Promise that resolves when the connection to shared PGlite is closed\n   */\n  async close() {\n    if (this.#closed) {\n      return\n    }\n    this.#closed = true\n    this.#broadcastChannel?.close()\n    this.#tabChannel?.close()\n    this.#releaseTabCloseLock?.()\n    this.#workerProcess.terminate()\n  }\n\n  /**\n   * Close the database when the object exits scope\n   * Stage 3 ECMAScript Explicit Resource Management\n   * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#using-declarations-and-explicit-resource-management\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close()\n  }\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  async execProtocolRaw(message: Uint8Array): Promise<Uint8Array> {\n    return (await this.#rpc('execProtocolRaw', message)) as Uint8Array\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(message: Uint8Array): Promise<ExecProtocolResult> {\n    return await this.#rpc('execProtocol', message)\n  }\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  async syncToFs() {\n    await this.#rpc('syncToFs')\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(\n    channel: string,\n    callback: (payload: string) => void,\n  ): Promise<() => Promise<void>> {\n    await this.waitReady\n    if (!this.#notifyListeners.has(channel)) {\n      this.#notifyListeners.set(channel, new Set())\n    }\n    this.#notifyListeners.get(channel)?.add(callback)\n    await this.exec(`LISTEN ${channel}`)\n    return async () => {\n      await this.unlisten(channel, callback)\n    }\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n  ): Promise<void> {\n    await this.waitReady\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback)\n    } else {\n      this.#notifyListeners.delete(channel)\n    }\n    if (this.#notifyListeners.get(channel)?.size === 0) {\n      // As we currently have a dedicated worker we can just unlisten\n      await this.exec(`UNLISTEN ${channel}`)\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.add(callback)\n    return () => {\n      this.#globalNotifyListeners.delete(callback)\n    }\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback)\n  }\n\n  #receiveNotification(channel: string, payload: string) {\n    const listeners = this.#notifyListeners.get(channel)\n    if (listeners) {\n      for (const listener of listeners) {\n        queueMicrotask(() => listener(payload))\n      }\n    }\n    for (const listener of this.#globalNotifyListeners) {\n      queueMicrotask(() => listener(channel, payload))\n    }\n  }\n\n  async dumpDataDir(): Promise<File | Blob> {\n    return (await this.#rpc('dumpDataDir')) as File | Blob\n  }\n\n  onLeaderChange(callback: () => void) {\n    this.#eventTarget.addEventListener('leader-change', callback)\n    return () => {\n      this.#eventTarget.removeEventListener('leader-change', callback)\n    }\n  }\n\n  offLeaderChange(callback: () => void) {\n    this.#eventTarget.removeEventListener('leader-change', callback)\n  }\n\n  async _handleBlob(blob?: File | Blob): Promise<void> {\n    await this.#rpc('_handleBlob', blob)\n  }\n\n  async _getWrittenBlob(): Promise<File | Blob | undefined> {\n    return await this.#rpc('_getWrittenBlob')\n  }\n\n  async _cleanupBlob(): Promise<void> {\n    await this.#rpc('_cleanupBlob')\n  }\n\n  async _checkReady() {\n    await this.waitReady\n  }\n\n  async _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireQueryLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseQueryLock')\n    }\n  }\n\n  async _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T> {\n    await this.#rpc('_acquireTransactionLock')\n    try {\n      return await fn()\n    } finally {\n      await this.#rpc('_releaseTransactionLock')\n    }\n  }\n}\n\nexport interface WorkerOptions {\n  init: (options: Exclude<PGliteWorkerOptions, 'extensions'>) => Promise<PGlite>\n}\n\nexport async function worker({ init }: WorkerOptions) {\n  // Send a message to the main thread to let it know we are here\n  postMessage({ type: 'here' })\n\n  // Await the main thread to send us the options\n  const options = await new Promise<Exclude<PGliteWorkerOptions, 'extensions'>>(\n    (resolve) => {\n      addEventListener(\n        'message',\n        (event) => {\n          if (event.data.type === 'init') {\n            resolve(event.data.options)\n          }\n        },\n        { once: true },\n      )\n    },\n  )\n\n  // ID for this multi-tab worker - this is used to identify the group of workers\n  // that are trying to elect a leader for a shared PGlite instance.\n  // It defaults to the URL of the worker, and the dataDir if provided\n  // but can be overridden by the options.\n  const id = options.id ?? `${import.meta.url}:${options.dataDir ?? ''}`\n\n  // Let the main thread know we are ready\n  postMessage({ type: 'ready', id })\n\n  const electionLockId = `pglite-election-lock:${id}`\n  const broadcastChannelId = `pglite-broadcast:${id}`\n  const broadcastChannel = new BroadcastChannel(broadcastChannelId)\n  const connectedTabs = new Set<string>()\n\n  // Await the main lock which is used to elect the leader\n  // We don't release this lock, its automatically released when the worker or\n  // tab is closed\n  await acquireLock(electionLockId)\n\n  // Now we are the leader, start the worker\n  const dbPromise = init(options)\n\n  // Start listening for messages from tabs\n  broadcastChannel.onmessage = async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'tab-here':\n        // A new tab has joined,\n        connectTab(msg.id, await dbPromise, connectedTabs)\n        break\n    }\n  }\n\n  // Notify the other tabs that we are the leader\n  broadcastChannel.postMessage({ type: 'leader-here', id })\n\n  // Let the main thread know we are the leader\n  postMessage({ type: 'leader-now' })\n\n  const db = await dbPromise\n\n  // Listen for notifications and broadcast them to all tabs\n  db.onNotification((channel, payload) => {\n    broadcastChannel.postMessage({ type: 'notify', channel, payload })\n  })\n}\n\nfunction connectTab(tabId: string, pg: PGlite, connectedTabs: Set<string>) {\n  if (connectedTabs.has(tabId)) {\n    return\n  }\n  connectedTabs.add(tabId)\n  const tabChannelId = `pglite-tab:${tabId}`\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  const tabChannel = new BroadcastChannel(tabChannelId)\n\n  // Use a tab close lock to unsubscribe the tab\n  navigator.locks.request(tabCloseLockId, () => {\n    return new Promise<void>((resolve) => {\n      // The tab has been closed, unsubscribe the tab broadcast channel\n      tabChannel.close()\n      connectedTabs.delete(tabId)\n      resolve()\n    })\n  })\n\n  const api = makeWorkerApi(tabId, pg)\n\n  tabChannel.addEventListener('message', async (event) => {\n    const msg = event.data\n    switch (msg.type) {\n      case 'rpc-call': {\n        await pg.waitReady\n        const { callId, method, args } = msg as WorkerRpcCall<WorkerRpcMethod>\n        try {\n          // @ts-ignore no apparent reason why it fails\n          const result = (await api[method](...args)) as WorkerRpcResult<\n            typeof method\n          >['result']\n          tabChannel.postMessage({\n            type: 'rpc-return',\n            callId,\n            result,\n          } satisfies WorkerRpcResult<typeof method>)\n        } catch (error) {\n          console.error(error)\n          tabChannel.postMessage({\n            type: 'rpc-error',\n            callId,\n            error: { message: (error as Error).message },\n          } satisfies WorkerRpcError)\n        }\n        break\n      }\n    }\n  })\n\n  // Send a message to the tab to let it know it's connected\n  tabChannel.postMessage({ type: 'connected' })\n}\n\nfunction makeWorkerApi(tabId: string, db: PGlite) {\n  let queryLockRelease: (() => void) | null = null\n  let transactionLockRelease: (() => void) | null = null\n\n  // If the tab is closed and it is holding a lock, release the the locks\n  // and rollback any pending transactions\n  const tabCloseLockId = `pglite-tab-close:${tabId}`\n  acquireLock(tabCloseLockId).then(() => {\n    if (transactionLockRelease) {\n      // rollback any pending transactions\n      db.exec('ROLLBACK')\n    }\n    queryLockRelease?.()\n    transactionLockRelease?.()\n  })\n\n  return {\n    async getDebugLevel() {\n      return db.debug\n    },\n    async close() {\n      await db.close()\n    },\n    async execProtocol(message: Uint8Array) {\n      const { messages, data } = await db.execProtocol(message)\n      if (data.byteLength !== data.buffer.byteLength) {\n        const buffer = new ArrayBuffer(data.byteLength)\n        const dataCopy = new Uint8Array(buffer)\n        dataCopy.set(data)\n        return { messages, data: dataCopy }\n      } else {\n        return { messages, data }\n      }\n    },\n    async execProtocolRaw(message: Uint8Array) {\n      const result = await db.execProtocolRaw(message)\n      if (result.byteLength !== result.buffer.byteLength) {\n        // The data is a slice of a larger buffer, this is potentially the whole\n        // memory of the WASM module. We copy it to a new Uint8Array and return that.\n        const buffer = new ArrayBuffer(result.byteLength)\n        const resultCopy = new Uint8Array(buffer)\n        resultCopy.set(result)\n        return resultCopy\n      } else {\n        return result\n      }\n    },\n    async dumpDataDir() {\n      return await db.dumpDataDir()\n    },\n    async syncToFs() {\n      return await db.syncToFs()\n    },\n    async _handleBlob(blob?: File | Blob) {\n      return await db._handleBlob(blob)\n    },\n    async _getWrittenBlob() {\n      return await db._getWrittenBlob()\n    },\n    async _cleanupBlob() {\n      return await db._cleanupBlob()\n    },\n    async _checkReady() {\n      return await db._checkReady()\n    },\n    async _acquireQueryLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveQuery(() => {\n          return new Promise<void>((release) => {\n            queryLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseQueryLock() {\n      queryLockRelease?.()\n      queryLockRelease = null\n    },\n    async _acquireTransactionLock() {\n      return new Promise<void>((resolve) => {\n        db._runExclusiveTransaction(() => {\n          return new Promise<void>((release) => {\n            transactionLockRelease = release\n            resolve()\n          })\n        })\n      })\n    },\n    async _releaseTransactionLock() {\n      transactionLockRelease?.()\n      transactionLockRelease = null\n    },\n  }\n}\n\nexport class LeaderChangedError extends Error {\n  constructor() {\n    super('Leader changed, pending operation in indeterminate state')\n  }\n}\n\nasync function acquireLock(lockId: string) {\n  let release\n  await new Promise<void>((resolve) => {\n    navigator.locks.request(lockId, () => {\n      return new Promise<void>((releaseCallback) => {\n        release = releaseCallback\n        resolve()\n      })\n    })\n  })\n  return release\n}\n\ntype WorkerApi = ReturnType<typeof makeWorkerApi>\n\ntype WorkerRpcMethod = keyof WorkerApi\n\ntype WorkerRpcCall<Method extends WorkerRpcMethod> = {\n  type: 'rpc-call'\n  callId: string\n  method: Method\n  args: Parameters<WorkerApi[Method]>\n}\n\ntype WorkerRpcResult<Method extends WorkerRpcMethod> = {\n  type: 'rpc-return'\n  callId: string\n  result: ReturnType<WorkerApi[Method]>\n}\n\ntype WorkerRpcError = {\n  type: 'rpc-error'\n  callId: string\n  error: any\n}\n\ntype WorkerRpcResponse<Method extends WorkerRpcMethod> =\n  | WorkerRpcResult<Method>\n  | WorkerRpcError\n"],"mappings":"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","names":["worker","resolve","message"]}